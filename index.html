<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Voxels of Life</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js"></script>
<style>
body {
  -webkit-user-select: none;  /* Chrome all / Safari all */
  -moz-user-select: none;     /* Firefox all */
  -ms-user-select: none;      /* IE 10+ */
  user-select: none;          /* Likely future */
  position: relative;
  margin: 0;
  padding: 0;
  background: #000;
  overflow: hidden;
}
</style>
</head>
<body>
<script>
var patterns = {
  glider: [
    [ 0, 1, 0 ],
    [ 0, 0, 1 ],
    [ 1, 1, 1 ]
  ],
  lwss: [
    [ 1, 0, 0, 1, 0 ],
    [ 0, 0, 0, 0, 1 ],
    [ 1, 0, 0, 0, 1 ],
    [ 0, 1, 1, 1, 1 ]
  ],
  pulsar: [
    [ 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0 ],
    [ 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0 ],
    [ 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
    [ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ],
    [ 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
    [ 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ],
    [ 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
    [ 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0 ],
    [ 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0 ]
  ]
};

var neighOffsets = [
  { x: 0, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 0 },
  { x: 1, y: 1 },
  { x: 0, y: 1 },
  { x: -1, y: 1 },
  { x: -1, y: 0 },
  { x: -1, y: -1 }
];

var camera, scene, renderer;
var group;

var matrix = [];

var MATRIX_SIZE = 40;
var CUBE_SIZE = 10;

function spawnCells(howMany) {
  for (var i = 0; i < howMany; i++) {
    matrix[Math.floor(Math.random() * MATRIX_SIZE * MATRIX_SIZE)] = true;
  }
}

var generations = [];

var cubes = [];

init();
animate();

function stamp(patternName) {
  var pattern = patterns[patternName];

  var cx = Math.floor((MATRIX_SIZE - pattern[0].length) / 2),
    cy = Math.floor((MATRIX_SIZE - pattern.length) / 2);

  for (var row = 0; row < pattern.length; row++) {
    var patternRow = pattern[row];
    for (var col = 0; col < patternRow.length; col++) {
      matrix[(cy + row) * MATRIX_SIZE + cx + col] = !!patternRow[col];
    }
  }
}

function init() {

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.z = 400;

  scene = new THREE.Scene();

  var ambientLight = new THREE.AmbientLight(0x000000);
  scene.add(ambientLight);

  var lights = [];
  lights[0] = new THREE.PointLight(0xffffff, 1, 0);
  lights[1] = new THREE.PointLight(0xffffff, 1, 0);
  lights[2] = new THREE.PointLight(0xffffff, 1, 0);

  lights[0].position.set(0, 1000, 0);
  lights[1].position.set(500, 1000, 500);
  lights[2].position.set(-500, -1000, -500);

  scene.add(lights[0]);
  scene.add(lights[1]);
  scene.add(lights[2]);

  var geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);

  group = new THREE.Group();

  var idx = 0;

  for (var k = 0; k < MATRIX_SIZE; k++) {
    var material = new THREE.MeshLambertMaterial({ color: Math.round((1 - Math.abs(k * 2 / MATRIX_SIZE - 1)) * 255) });

    for (var i = 0; i < MATRIX_SIZE; i++) {
      for (var j = 0; j < MATRIX_SIZE; j++) {
        var mesh = new THREE.Mesh(geometry, material);

        mesh.translateX((i - MATRIX_SIZE / 2) * CUBE_SIZE);
        mesh.translateY((j - MATRIX_SIZE / 2) * CUBE_SIZE);
        mesh.translateZ((k - MATRIX_SIZE / 2) * CUBE_SIZE);

        mesh.visible = false;

        group.add(mesh);

        cubes[idx++] = mesh;
      }
    }
  }

  group.add(mesh);

  scene.add(group);

  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', onWindowResize, false);

  //spawnCells(100);
  stamp('pulsar');

  drawMatrix();
}

function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);

}

function animate(ts) {
  requestAnimationFrame(animate);

  drawMatrix();

  if (!isPaused) {
    progressMatrix();
  }

  group.rotation.z += 0.005;

  renderer.render(scene, camera);
}

var isPaused = false;

var isSpawning;

var isMouseDown = false,
  mouseDownPoint,
  mouseDownRotation;

renderer.domElement.addEventListener('mousedown', function (evt) {
  isMouseDown = true;

  mouseDownPoint = {
    x: evt.offsetX,
    y: evt.offsetY
  };

  mouseDownRotation = {
    x: group.rotation.x,
    y: group.rotation.y
  };
});

renderer.domElement.addEventListener('mouseup', function (evt) {
  isMouseDown = false;
});

renderer.domElement.addEventListener('mousemove', function (evt) {
  if (isMouseDown) {
    var dx = evt.offsetX - mouseDownPoint.x,
      dy = evt.offsetY - mouseDownPoint.y;

    group.rotation.y = mouseDownRotation.y + 2 * Math.PI * dx / renderer.domElement.width;
    group.rotation.x = mouseDownRotation.x + 2 * Math.PI * dy / renderer.domElement.height;

  }
});

function drawMatrix() {
  var idx = 0;

  for (var gen = 0; gen < MATRIX_SIZE; gen++) {
    var matrix = generations[gen];

    for (var row = 0; row < MATRIX_SIZE; row++) {
      for (var col = 0; col < MATRIX_SIZE; col++) {
        cubes[idx].visible = !!(matrix && matrix[row * MATRIX_SIZE + col]);
        idx++;
      }
    }
  }
}

function progressMatrix() {
  var idx = 0;

  var newMatrix = [];

  for (var row = 0; row < MATRIX_SIZE; row++) {
    for (var col = 0; col < MATRIX_SIZE; col++) {
      var neighCount = 0;

      newMatrix[idx] = matrix[idx];

      for (var neigh = 0; neigh < 8; neigh++) {
        var neighX = (col + neighOffsets[neigh].x + MATRIX_SIZE) % MATRIX_SIZE;
        var neighY = (row + neighOffsets[neigh].y + MATRIX_SIZE) % MATRIX_SIZE;

        if (matrix[neighY * MATRIX_SIZE + neighX]) {
          neighCount++;
        }
      }

      if (matrix[idx]) {
        if (neighCount < 2) {
          newMatrix[idx] = false;
        } else if (neighCount > 3) {
          newMatrix[idx] = false;
        }
      } else {
        if (neighCount === 3) {
          newMatrix[idx] = true;
        }
      }

      idx++;
    }
  }

  generations.push(matrix);

  if (generations.length > MATRIX_SIZE) {
    generations.shift();
  }

  matrix = newMatrix;
}

var gui = new dat.GUI();

var voxels = {
  pattern: 'glider',
  clear: function () {
    matrix = [];
  },
  spawn: function () {
    spawnCells(100);
  },
  stamp: function () {
    stamp(this.pattern);
  },
  pause: function () {
    isPaused = !isPaused;
  }
};

var patternFolder = gui.addFolder('Pattern');
patternFolder.open();
patternFolder.add(voxels, 'pattern', Object.keys(patterns));
patternFolder.add(voxels, 'stamp');

var randomFolder = gui.addFolder('Random');
randomFolder.open();
randomFolder.add(voxels, 'spawn');

gui.add(voxels, 'clear');
gui.add(voxels, 'pause');
</script>
</body>
</html>
