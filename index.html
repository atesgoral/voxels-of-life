<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
<style>
body {
    -webkit-user-select: none;  /* Chrome all / Safari all */
    -moz-user-select: none;     /* Firefox all */
    -ms-user-select: none;      /* IE 10+ */
    user-select: none;          /* Likely future */          
    position: relative;
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;  
}
.controls {
    position: absolute;
    top: 0;
    left: 0;
    padding: 10px;
}
</style>
</head>
<body>
    <div class="controls">
        <button id="clear">Clear</button>
        <button id="spawn">Spawn</button>
        <button id="pause">Pause</button>
        <select id="pattern">
            <option selected>glider</option>
            <option>lwss</option>
            <option>pulsar</option>
        </select>
        <button id="stamp">Stamp</button>
    </div>

<script>
var patterns = {
    glider: [
        [ 0, 1, 0 ],
        [ 0, 0, 1 ],
        [ 1, 1, 1 ]
    ],
    lwss: [
        [ 1, 0, 0, 1, 0 ],
        [ 0, 0, 0, 0, 1 ],
        [ 1, 0, 0, 0, 1 ],
        [ 0, 1, 1, 1, 1 ]
    ],
    pulsar: [
        [ 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0 ],
        [ 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0 ],
        [ 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1 ],
        [ 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
        [ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ],
        [ 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ],
        [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
        [ 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0 ],
        [ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ],
        [ 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
        [ 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1 ],
        [ 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0 ],
        [ 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0 ]
    ]
};

var neighOffsets = [
    { x: 0, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 0 },
    { x: 1, y: 1 },
    { x: 0, y: 1 },
    { x: -1, y: 1 },
    { x: -1, y: 0 },
    { x: -1, y: -1 }
];

var camera, scene, renderer;
var group;

var matrix = [];

var MATRIX_SIZE = 40;
var CUBE_SIZE = 5;

function spawnCells(howMany) {
    for (var i = 0; i < howMany; i++) {
        matrix[Math.floor(Math.random() * MATRIX_SIZE * MATRIX_SIZE)] = true;
    }
}

var generations = [];

var cubes = [];

init();
animate();

function stamp(patternName) {
    var pattern = patterns[patternName];

    var cx = Math.floor((MATRIX_SIZE - pattern[0].length) / 2),
        cy = Math.floor((MATRIX_SIZE - pattern.length) / 2);

    for (var row = 0; row < pattern.length; row++) {
        var patternRow = pattern[row];
        for (var col = 0; col < patternRow.length; col++) {
            matrix[(cy + row) * MATRIX_SIZE + cx + col] = !!patternRow[col];
        }
    }
}

function init() {

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.z = 400;

    scene = new THREE.Scene();

    var ambientLight = new THREE.AmbientLight(0x000000);
    scene.add( ambientLight );

    var lights = [];
    lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
    lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
    lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );
    
    lights[0].position.set(0, 1000, 0);
    lights[1].position.set(500, 1000, 500);
    lights[2].position.set(-500, -1000, -500);

    scene.add( lights[0] );
    scene.add( lights[1] );
    scene.add( lights[2] );
    
    var geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    var material = new THREE.MeshLambertMaterial({ color: 0x0000ff });

    group = new THREE.Group();

    var idx = 0;

    for (var k = 0; k < MATRIX_SIZE; k++) {
        for (var i = 0; i < MATRIX_SIZE; i++) {
            for (var j = 0; j < MATRIX_SIZE; j++) {
                var mesh = new THREE.Mesh(geometry, material);

                mesh.translateX((i - MATRIX_SIZE / 2) * CUBE_SIZE);
                mesh.translateY((j - MATRIX_SIZE / 2) * CUBE_SIZE);
                mesh.translateZ((k - MATRIX_SIZE / 2) * CUBE_SIZE);

                mesh.visible = false;

                group.add(mesh);

                cubes[idx++] = mesh;
            }
        }
    }

    group.add(mesh);

    scene.add( group );

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    window.addEventListener( 'resize', onWindowResize, false );

    //spawnCells(100);
    stamp('pulsar');

    drawMatrix();    
}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate(ts) {

    requestAnimationFrame( animate );

    drawMatrix();

    if (!isPaused) {
        progressMatrix();
    }

    // group.rotation.x += 0.005;
    // group.rotation.y += 0.01;
    group.rotation.z += 0.005;

    renderer.render( scene, camera );
}


var pause = document.getElementById('pause');


document.getElementById('clear').addEventListener('click', function () {
    matrix = [];
});

document.getElementById('spawn').addEventListener('click', function () {
    spawnCells(100);
});

document.getElementById('stamp').addEventListener('click', function () {
    stamp(document.getElementById('pattern').value);
});

var isPaused = false;

var isSpawning;

pause.addEventListener('click', function () {
    isPaused = !isPaused;
    
    pause.innerHTML = isPaused ? 'Resume' : 'Pause';    
});

var isMouseDown = false,
    mouseDownPoint,
    mouseDownRotation;

renderer.domElement.addEventListener('mousedown', function (evt) {    
    isMouseDown = true;

    mouseDownPoint = {
        x: evt.offsetX,
        y: evt.offsetY
    };

    mouseDownRotation = {
        x: group.rotation.x,
        y: group.rotation.y
    };
});

renderer.domElement.addEventListener('mouseup', function (evt) {
    isMouseDown = false;
});

renderer.domElement.addEventListener('mousemove', function (evt) {
    if (isMouseDown) {
        var dx = evt.offsetX - mouseDownPoint.x,
            dy = evt.offsetY - mouseDownPoint.y;

        group.rotation.y = mouseDownRotation.y + 2 * Math.PI * dx / renderer.domElement.width;
        group.rotation.x = mouseDownRotation.x + 2 * Math.PI * dy / renderer.domElement.height;

    }
});

function drawMatrix() {
    var idx = 0;

    for (var gen = 0; gen < MATRIX_SIZE; gen++) {
        var matrix = generations[gen];

        for (var row = 0; row < MATRIX_SIZE; row++) {
            for (var col = 0; col < MATRIX_SIZE; col++) {
                cubes[idx].visible = matrix && !!matrix[row * MATRIX_SIZE + col];
                idx++;
            }
        }
    }
}

function progressMatrix() {
    var idx = 0;
    
    var newMatrix = [];
        
    for (var row = 0; row < MATRIX_SIZE; row++) {
        for (var col = 0; col < MATRIX_SIZE; col++) {
            var neighCount = 0;
            
            newMatrix[idx] = matrix[idx];
            
            for (var neigh = 0; neigh < 8; neigh++) {
                var neighX = (col + neighOffsets[neigh].x + MATRIX_SIZE) % MATRIX_SIZE;
                var neighY = (row + neighOffsets[neigh].y + MATRIX_SIZE) % MATRIX_SIZE;
                
                if (matrix[neighY * MATRIX_SIZE + neighX]) {
                    neighCount++;
                }
            }           
                       
            if (matrix[idx]) {
                if (neighCount < 2) {
                    newMatrix[idx] = false;
                } else if (neighCount > 3) {
                    newMatrix[idx] = false;
                }
            } else {
                if (neighCount === 3) {
                    newMatrix[idx] = true;
                }
            }
        
        	idx++;
        }
    }

    generations.push(matrix);

    if (generations.length > MATRIX_SIZE) {
        generations.shift();
    }
    
    matrix = newMatrix;
}
</script>
</body>
</html>